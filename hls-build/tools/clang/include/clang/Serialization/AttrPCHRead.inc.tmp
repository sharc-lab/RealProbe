/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Attribute deserialization code                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

  switch (Kind) {
  case attr::AMDGPUFlatWorkGroupSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned min = Record.readInt();
    unsigned max = Record.readInt();
    New = new (Context) AMDGPUFlatWorkGroupSizeAttr(Range, Context, min, max, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AMDGPUNumSGPR: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned numSGPR = Record.readInt();
    New = new (Context) AMDGPUNumSGPRAttr(Range, Context, numSGPR, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AMDGPUNumVGPR: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned numVGPR = Record.readInt();
    New = new (Context) AMDGPUNumVGPRAttr(Range, Context, numVGPR, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AMDGPUWavesPerEU: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned min = Record.readInt();
    unsigned max = Record.readInt();
    New = new (Context) AMDGPUWavesPerEUAttr(Range, Context, min, max, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::APFifoInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    bool isRegister = Record.readInt();
    Expr * depth = Record.readExpr();
    std::string signalName= Record.readString();
    New = new (Context) APFifoInterfaceAttr(Range, Context, port, isRegister, depth, signalName, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::APScalarInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    std::string mode= Record.readString();
    bool isRegister = Record.readInt();
    std::string signalName= Record.readString();
    New = new (Context) APScalarInterfaceAttr(Range, Context, port, mode, isRegister, signalName, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::APScalarInterruptInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    std::string mode= Record.readString();
    bool isRegister = Record.readInt();
    std::string signalName= Record.readString();
    Expr * interrupt = Record.readExpr();
    New = new (Context) APScalarInterruptInterfaceAttr(Range, Context, port, mode, isRegister, signalName, interrupt, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ARMInterrupt: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    ARMInterruptAttr::InterruptType interrupt(static_cast<ARMInterruptAttr::InterruptType>(Record.readInt()));
    New = new (Context) ARMInterruptAttr(Range, Context, interrupt, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AVRInterrupt: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AVRInterruptAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AVRSignal: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AVRSignalAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AXISAdaptor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    AXISAdaptorAttr::AXISRegisterModeType registerMode(static_cast<AXISAdaptorAttr::AXISRegisterModeType>(Record.readInt()));
    AXISAdaptorAttr::DirectionType direction(static_cast<AXISAdaptorAttr::DirectionType>(Record.readInt()));
    New = new (Context) AXISAdaptorAttr(Range, Context, name, registerMode, direction, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AXIStreamInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    bool isRegister = Record.readInt();
    AXIStreamInterfaceAttr::RegisterModeEnum registerMode(static_cast<AXIStreamInterfaceAttr::RegisterModeEnum>(Record.readInt()));
    Expr * depth = Record.readExpr();
    std::string signalName= Record.readString();
    std::string bundleName= Record.readString();
    New = new (Context) AXIStreamInterfaceAttr(Range, Context, port, isRegister, registerMode, depth, signalName, bundleName, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AbiTag: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned tagsSize = Record.readInt();
    SmallVector<StringRef, 4> tags;
    tags.reserve(tagsSize);
    SmallVector<std::string, 4> tagsStorage;
    tagsStorage.reserve(tagsSize);
    for (unsigned i = 0; i != tagsSize; ++i)
      tagsStorage.push_back(Record.readString());
    for (unsigned i = 0; i != tagsSize; ++i)
      tags.push_back(tagsStorage[i]);
    New = new (Context) AbiTagAttr(Range, Context, tags.data(), tagsSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AcquireCapability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AcquireCapabilityAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AcquiredAfter: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AcquiredAfterAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AcquiredBefore: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AcquiredBeforeAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Alias: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string aliasee= Record.readString();
    New = new (Context) AliasAttr(Range, Context, aliasee, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AlignMac68k: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AlignMac68kAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AlignValue: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * alignment = Record.readExpr();
    New = new (Context) AlignValueAttr(Range, Context, alignment, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Aligned: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool isalignmentExpr = Record.readInt();
    void *alignmentPtr;
    if (isalignmentExpr)
      alignmentPtr = Record.readExpr();
    else
      alignmentPtr = Record.getTypeSourceInfo();
    New = new (Context) AlignedAttr(Range, Context, isalignmentExpr, alignmentPtr, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AllocAlign: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int paramIndex = Record.readInt();
    New = new (Context) AllocAlignAttr(Range, Context, paramIndex, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AllocSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int elemSizeParam = Record.readInt();
    int numElemsParam = Record.readInt();
    New = new (Context) AllocSizeAttr(Range, Context, elemSizeParam, numElemsParam, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AlwaysInline: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AlwaysInlineAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AnalyzerNoReturn: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AnalyzerNoReturnAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Annotate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string annotation= Record.readString();
    New = new (Context) AnnotateAttr(Range, Context, annotation, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AnyX86Interrupt: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AnyX86InterruptAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AnyX86NoCallerSavedRegisters: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) AnyX86NoCallerSavedRegistersAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ArcWeakrefUnavailable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ArcWeakrefUnavailableAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ArgumentWithTypeTag: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * argumentKind = Record.getIdentifierInfo();
    unsigned argumentIdx = Record.readInt();
    unsigned typeTagIdx = Record.readInt();
    bool isPointer = Record.readInt();
    New = new (Context) ArgumentWithTypeTagAttr(Range, Context, argumentKind, argumentIdx, typeTagIdx, isPointer, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AsmLabel: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string label= Record.readString();
    New = new (Context) AsmLabelAttr(Range, Context, label, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AssertCapability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AssertCapabilityAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AssertExclusiveLock: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AssertExclusiveLockAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AssertSharedLock: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) AssertSharedLockAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::AssumeAligned: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * alignment = Record.readExpr();
    Expr * offset = Record.readExpr();
    New = new (Context) AssumeAlignedAttr(Range, Context, alignment, offset, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Availability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * platform = Record.getIdentifierInfo();
    VersionTuple introduced= Record.readVersionTuple();
    VersionTuple deprecated= Record.readVersionTuple();
    VersionTuple obsoleted= Record.readVersionTuple();
    bool unavailable = Record.readInt();
    std::string message= Record.readString();
    bool strict = Record.readInt();
    std::string replacement= Record.readString();
    New = new (Context) AvailabilityAttr(Range, Context, platform, introduced, deprecated, obsoleted, unavailable, message, strict, replacement, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::BRAMAdaptor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    BRAMAdaptorAttr::ModeType mode(static_cast<BRAMAdaptorAttr::ModeType>(Record.readInt()));
    Expr * rAMType = Record.readExpr();
    Expr * rAMImpl = Record.readExpr();
    Expr * latency = Record.readExpr();
    New = new (Context) BRAMAdaptorAttr(Range, Context, name, mode, rAMType, rAMImpl, latency, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Blocks: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    BlocksAttr::BlockType type(static_cast<BlocksAttr::BlockType>(Record.readInt()));
    New = new (Context) BlocksAttr(Range, Context, type, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::C11NoReturn: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) C11NoReturnAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CDecl: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CDeclAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CFAuditedTransfer: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CFAuditedTransferAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CFConsumed: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CFConsumedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CFReturnsNotRetained: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CFReturnsNotRetainedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CFReturnsRetained: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CFReturnsRetainedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CFUnknownTransfer: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CFUnknownTransferAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDAConstant: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDAConstantAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDADevice: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDADeviceAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDAGlobal: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDAGlobalAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDAHost: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDAHostAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDAInvalidTarget: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDAInvalidTargetAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDALaunchBounds: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * maxThreads = Record.readExpr();
    Expr * minBlocks = Record.readExpr();
    New = new (Context) CUDALaunchBoundsAttr(Range, Context, maxThreads, minBlocks, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CUDAShared: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CUDASharedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CXX11NoReturn: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CXX11NoReturnAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CallableWhen: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned callableStatesSize = Record.readInt();
    SmallVector<CallableWhenAttr::ConsumedState, 4> callableStates;
    callableStates.reserve(callableStatesSize);
    for (unsigned i = callableStatesSize; i; --i)
      callableStates.push_back(static_cast<CallableWhenAttr::ConsumedState>(Record.readInt()));
    New = new (Context) CallableWhenAttr(Range, Context, callableStates.data(), callableStatesSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Capability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) CapabilityAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CapturedRecord: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CapturedRecordAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CarriesDependency: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CarriesDependencyAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Cleanup: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    FunctionDecl * functionDecl = Record.GetLocalDeclAs<FunctionDecl >(Record.readInt());
    New = new (Context) CleanupAttr(Range, Context, functionDecl, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::CodeGenType: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    TypeSourceInfo * type = Record.getTypeSourceInfo();
    New = new (Context) CodeGenTypeAttr(Range, Context, type, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Cold: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ColdAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Common: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) CommonAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Const: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ConstAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Constructor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int priority = Record.readInt();
    New = new (Context) ConstructorAttr(Range, Context, priority, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Consumable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    ConsumableAttr::ConsumedState defaultState(static_cast<ConsumableAttr::ConsumedState>(Record.readInt()));
    New = new (Context) ConsumableAttr(Range, Context, defaultState, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ConsumableAutoCast: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ConsumableAutoCastAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ConsumableSetOnRead: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ConsumableSetOnReadAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Convergent: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ConvergentAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::DLLExport: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) DLLExportAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::DLLImport: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) DLLImportAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Deprecated: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string message= Record.readString();
    std::string replacement= Record.readString();
    New = new (Context) DeprecatedAttr(Range, Context, message, replacement, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Destructor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int priority = Record.readInt();
    New = new (Context) DestructorAttr(Range, Context, priority, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::DiagnoseIf: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * cond = Record.readExpr();
    std::string message= Record.readString();
    DiagnoseIfAttr::DiagnosticType diagnosticType(static_cast<DiagnoseIfAttr::DiagnosticType>(Record.readInt()));
    bool argDependent = Record.readInt();
    NamedDecl * parent = Record.GetLocalDeclAs<NamedDecl >(Record.readInt());
    New = new (Context) DiagnoseIfAttr(Range, Context, cond, message, diagnosticType, argDependent, parent, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::DisableTailCalls: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) DisableTailCallsAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::EmptyBases: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) EmptyBasesAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::EnableIf: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * cond = Record.readExpr();
    std::string message= Record.readString();
    New = new (Context) EnableIfAttr(Range, Context, cond, message, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::EnumExtensibility: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    EnumExtensibilityAttr::Kind extensibility(static_cast<EnumExtensibilityAttr::Kind>(Record.readInt()));
    New = new (Context) EnumExtensibilityAttr(Range, Context, extensibility, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ExclusiveTrylockFunction: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * successValue = Record.readExpr();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) ExclusiveTrylockFunctionAttr(Range, Context, successValue, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ExternalSourceSymbol: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string language= Record.readString();
    std::string definedIn= Record.readString();
    bool generatedDeclaration = Record.readInt();
    New = new (Context) ExternalSourceSymbolAttr(Range, Context, language, definedIn, generatedDeclaration, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAAddressInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string mode= Record.readString();
    std::string adaptor= Record.readString();
    FPGAAddressInterfaceAttr::OffsetModeType offsetMode(static_cast<FPGAAddressInterfaceAttr::OffsetModeType>(Record.readInt()));
    New = new (Context) FPGAAddressInterfaceAttr(Range, Context, mode, adaptor, offsetMode, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGADataFootPrintHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * depth = Record.readExpr();
    New = new (Context) FPGADataFootPrintHintAttr(Range, Context, depth, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAFunctionCtrlInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string mode= Record.readString();
    std::string name= Record.readString();
    New = new (Context) FPGAFunctionCtrlInterfaceAttr(Range, Context, mode, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiLatency: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * latency = Record.readExpr();
    New = new (Context) FPGAMaxiLatencyAttr(Range, Context, latency, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiMaxWidenBitwidth: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * maxWidenBitwidth = Record.readExpr();
    New = new (Context) FPGAMaxiMaxWidenBitwidthAttr(Range, Context, maxWidenBitwidth, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiNumRdOutstand: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * numRdOutstand = Record.readExpr();
    New = new (Context) FPGAMaxiNumRdOutstandAttr(Range, Context, numRdOutstand, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiNumWtOutstand: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * numWtOutstand = Record.readExpr();
    New = new (Context) FPGAMaxiNumWtOutstandAttr(Range, Context, numWtOutstand, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiRdBurstLen: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * rdBurstLen = Record.readExpr();
    New = new (Context) FPGAMaxiRdBurstLenAttr(Range, Context, rdBurstLen, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAMaxiWtBurstLen: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * wtBurstLen = Record.readExpr();
    New = new (Context) FPGAMaxiWtBurstLenAttr(Range, Context, wtBurstLen, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGARegister: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FPGARegisterAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAResourceHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string core= Record.readString();
    std::string metadata= Record.readString();
    Expr * latency = Record.readExpr();
    New = new (Context) FPGAResourceHintAttr(Range, Context, core, metadata, latency, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAResourceLimitHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * instanceType = Record.getIdentifierInfo();
    IdentifierInfo * instanceName = Record.getIdentifierInfo();
    Expr * limit = Record.readExpr();
    New = new (Context) FPGAResourceLimitHintAttr(Range, Context, instanceType, instanceName, limit, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAScalarInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string mode= Record.readString();
    std::string adaptor= Record.readString();
    New = new (Context) FPGAScalarInterfaceAttr(Range, Context, mode, adaptor, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGAScalarInterfaceWrapper: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string mode= Record.readString();
    std::string adaptor= Record.readString();
    Expr * offset = Record.readExpr();
    New = new (Context) FPGAScalarInterfaceWrapperAttr(Range, Context, mode, adaptor, offset, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FPGASignalName: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) FPGASignalNameAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FallThrough: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FallThroughAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FastCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FastCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Final: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FinalAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FlagEnum: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FlagEnumAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Flatten: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) FlattenAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Format: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * type = Record.getIdentifierInfo();
    int formatIdx = Record.readInt();
    int firstArg = Record.readInt();
    New = new (Context) FormatAttr(Range, Context, type, formatIdx, firstArg, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::FormatArg: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int formatIdx = Record.readInt();
    New = new (Context) FormatArgAttr(Range, Context, formatIdx, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::GNUInline: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) GNUInlineAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::GuardedBy: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * arg = Record.readExpr();
    New = new (Context) GuardedByAttr(Range, Context, arg, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::GuardedVar: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) GuardedVarAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::HLSPreserve: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) HLSPreserveAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Hot: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) HotAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::IBAction: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) IBActionAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::IBOutlet: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) IBOutletAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::IBOutletCollection: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    TypeSourceInfo * interface_ = Record.getTypeSourceInfo();
    New = new (Context) IBOutletCollectionAttr(Range, Context, interface_, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::IFunc: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string resolver= Record.readString();
    New = new (Context) IFuncAttr(Range, Context, resolver, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::InitPriority: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned priority = Record.readInt();
    New = new (Context) InitPriorityAttr(Range, Context, priority, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::InitSeg: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string section= Record.readString();
    New = new (Context) InitSegAttr(Range, Context, section, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::IntelOclBicc: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) IntelOclBiccAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::InternalLinkage: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) InternalLinkageAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::LTOVisibilityPublic: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) LTOVisibilityPublicAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::LayoutVersion: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned version = Record.readInt();
    New = new (Context) LayoutVersionAttr(Range, Context, version, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::LockReturned: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * arg = Record.readExpr();
    New = new (Context) LockReturnedAttr(Range, Context, arg, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::LocksExcluded: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) LocksExcludedAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::LoopHint: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    LoopHintAttr::OptionType option(static_cast<LoopHintAttr::OptionType>(Record.readInt()));
    LoopHintAttr::LoopHintState state(static_cast<LoopHintAttr::LoopHintState>(Record.readInt()));
    Expr * value = Record.readExpr();
    New = new (Context) LoopHintAttr(Range, Context, option, state, value, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MAXIAdaptor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    Expr * numReadOutstanding = Record.readExpr();
    Expr * numWriteOutstanding = Record.readExpr();
    Expr * maxReadBurstLength = Record.readExpr();
    Expr * maxWriteBurstLength = Record.readExpr();
    Expr * latency = Record.readExpr();
    New = new (Context) MAXIAdaptorAttr(Range, Context, name, numReadOutstanding, numWriteOutstanding, maxReadBurstLength, maxWriteBurstLength, latency, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MAXIInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    std::string bundleName= Record.readString();
    Expr * depth = Record.readExpr();
    MAXIInterfaceAttr::OffsetModeType offsetMode(static_cast<MAXIInterfaceAttr::OffsetModeType>(Record.readInt()));
    std::string signalName= Record.readString();
    Expr * numReadOutstanding = Record.readExpr();
    Expr * numWriteOutstanding = Record.readExpr();
    Expr * maxReadBurstLength = Record.readExpr();
    Expr * maxWriteBurstLength = Record.readExpr();
    Expr * latency = Record.readExpr();
    Expr * maxWidenBitWidth = Record.readExpr();
    Expr * channel = Record.readExpr();
    New = new (Context) MAXIInterfaceAttr(Range, Context, port, bundleName, depth, offsetMode, signalName, numReadOutstanding, numWriteOutstanding, maxReadBurstLength, maxWriteBurstLength, latency, maxWidenBitWidth, channel, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSABI: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MSABIAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSInheritance: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool bestCase = Record.readInt();
    New = new (Context) MSInheritanceAttr(Range, Context, bestCase, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSNoVTable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MSNoVTableAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSP430Interrupt: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned number = Record.readInt();
    New = new (Context) MSP430InterruptAttr(Range, Context, number, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSStruct: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MSStructAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MSVtorDisp: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned vdm = Record.readInt();
    New = new (Context) MSVtorDispAttr(Range, Context, vdm, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MaxFieldAlignment: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned alignment = Record.readInt();
    New = new (Context) MaxFieldAlignmentAttr(Range, Context, alignment, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MayAlias: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MayAliasAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MemoryInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    std::string mode= Record.readString();
    std::string storageType= Record.readString();
    Expr * latency = Record.readExpr();
    std::string signalName= Record.readString();
    Expr * depth = Record.readExpr();
    New = new (Context) MemoryInterfaceAttr(Range, Context, port, mode, storageType, latency, signalName, depth, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MicroMips: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MicroMipsAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MinSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MinSizeAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Mips16: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) Mips16Attr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MipsInterrupt: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    MipsInterruptAttr::InterruptType interrupt(static_cast<MipsInterruptAttr::InterruptType>(Record.readInt()));
    New = new (Context) MipsInterruptAttr(Range, Context, interrupt, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MipsLongCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MipsLongCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::MipsShortCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) MipsShortCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Mode: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * mode = Record.getIdentifierInfo();
    New = new (Context) ModeAttr(Range, Context, mode, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NSConsumed: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NSConsumedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NSConsumesSelf: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NSConsumesSelfAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NSReturnsAutoreleased: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NSReturnsAutoreleasedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NSReturnsNotRetained: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NSReturnsNotRetainedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NSReturnsRetained: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NSReturnsRetainedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Naked: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NakedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoAlias: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoAliasAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoCommon: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoCommonAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoCtor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoCtorAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoDebug: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoDebugAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoDuplicate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoDuplicateAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoEscape: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoEscapeAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoInline: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoInlineAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoInstrumentFunction: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoInstrumentFunctionAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoMicroMips: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoMicroMipsAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoMips16: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoMips16Attr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoReturn: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoReturnAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoSanitize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned sanitizersSize = Record.readInt();
    SmallVector<StringRef, 4> sanitizers;
    sanitizers.reserve(sanitizersSize);
    SmallVector<std::string, 4> sanitizersStorage;
    sanitizersStorage.reserve(sanitizersSize);
    for (unsigned i = 0; i != sanitizersSize; ++i)
      sanitizersStorage.push_back(Record.readString());
    for (unsigned i = 0; i != sanitizersSize; ++i)
      sanitizers.push_back(sanitizersStorage[i]);
    New = new (Context) NoSanitizeAttr(Range, Context, sanitizers.data(), sanitizersSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoSplitStack: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoSplitStackAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoThreadSafetyAnalysis: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoThreadSafetyAnalysisAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NoThrow: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NoThrowAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NonNull: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<unsigned, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readInt());
    New = new (Context) NonNullAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::NotTailCalled: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) NotTailCalledAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OMPCaptureKind: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned captureKind = Record.readInt();
    New = new (Context) OMPCaptureKindAttr(Range, Context, captureKind, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OMPCaptureNoInit: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OMPCaptureNoInitAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OMPDeclareSimdDecl: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    OMPDeclareSimdDeclAttr::BranchStateTy branchState(static_cast<OMPDeclareSimdDeclAttr::BranchStateTy>(Record.readInt()));
    Expr * simdlen = Record.readExpr();
    unsigned uniformsSize = Record.readInt();
    SmallVector<Expr *, 4> uniforms;
    uniforms.reserve(uniformsSize);
    for (unsigned i = 0; i != uniformsSize; ++i)
      uniforms.push_back(Record.readExpr());
    unsigned alignedsSize = Record.readInt();
    SmallVector<Expr *, 4> aligneds;
    aligneds.reserve(alignedsSize);
    for (unsigned i = 0; i != alignedsSize; ++i)
      aligneds.push_back(Record.readExpr());
    unsigned alignmentsSize = Record.readInt();
    SmallVector<Expr *, 4> alignments;
    alignments.reserve(alignmentsSize);
    for (unsigned i = 0; i != alignmentsSize; ++i)
      alignments.push_back(Record.readExpr());
    unsigned linearsSize = Record.readInt();
    SmallVector<Expr *, 4> linears;
    linears.reserve(linearsSize);
    for (unsigned i = 0; i != linearsSize; ++i)
      linears.push_back(Record.readExpr());
    unsigned modifiersSize = Record.readInt();
    SmallVector<unsigned, 4> modifiers;
    modifiers.reserve(modifiersSize);
    for (unsigned i = 0; i != modifiersSize; ++i)
      modifiers.push_back(Record.readInt());
    unsigned stepsSize = Record.readInt();
    SmallVector<Expr *, 4> steps;
    steps.reserve(stepsSize);
    for (unsigned i = 0; i != stepsSize; ++i)
      steps.push_back(Record.readExpr());
    New = new (Context) OMPDeclareSimdDeclAttr(Range, Context, branchState, simdlen, uniforms.data(), uniformsSize, aligneds.data(), alignedsSize, alignments.data(), alignmentsSize, linears.data(), linearsSize, modifiers.data(), modifiersSize, steps.data(), stepsSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OMPDeclareTargetDecl: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    OMPDeclareTargetDeclAttr::MapTypeTy mapType(static_cast<OMPDeclareTargetDeclAttr::MapTypeTy>(Record.readInt()));
    New = new (Context) OMPDeclareTargetDeclAttr(Range, Context, mapType, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OMPThreadPrivateDecl: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OMPThreadPrivateDeclAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCBoxable: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCBoxableAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCBridge: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * bridgedType = Record.getIdentifierInfo();
    New = new (Context) ObjCBridgeAttr(Range, Context, bridgedType, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCBridgeMutable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * bridgedType = Record.getIdentifierInfo();
    New = new (Context) ObjCBridgeMutableAttr(Range, Context, bridgedType, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCBridgeRelated: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * relatedClass = Record.getIdentifierInfo();
    IdentifierInfo * classMethod = Record.getIdentifierInfo();
    IdentifierInfo * instanceMethod = Record.getIdentifierInfo();
    New = new (Context) ObjCBridgeRelatedAttr(Range, Context, relatedClass, classMethod, instanceMethod, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCDesignatedInitializer: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCDesignatedInitializerAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCException: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCExceptionAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCExplicitProtocolImpl: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCExplicitProtocolImplAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCIndependentClass: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCIndependentClassAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCMethodFamily: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    ObjCMethodFamilyAttr::FamilyKind family(static_cast<ObjCMethodFamilyAttr::FamilyKind>(Record.readInt()));
    New = new (Context) ObjCMethodFamilyAttr(Range, Context, family, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCNSObject: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCNSObjectAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCPreciseLifetime: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCPreciseLifetimeAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCRequiresPropertyDefs: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCRequiresPropertyDefsAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCRequiresSuper: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCRequiresSuperAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCReturnsInnerPointer: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCReturnsInnerPointerAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCRootClass: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCRootClassAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCRuntimeName: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string metadataName= Record.readString();
    New = new (Context) ObjCRuntimeNameAttr(Range, Context, metadataName, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCRuntimeVisible: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCRuntimeVisibleAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ObjCSubclassingRestricted: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ObjCSubclassingRestrictedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OpenCLAccess: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OpenCLAccessAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OpenCLIntelReqdSubGroupSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned subGroupSize = Record.readInt();
    New = new (Context) OpenCLIntelReqdSubGroupSizeAttr(Range, Context, subGroupSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OpenCLKernel: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OpenCLKernelAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OpenCLUnrollHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * unrollHint = Record.readExpr();
    bool skipExitCheck = Record.readInt();
    New = new (Context) OpenCLUnrollHintAttr(Range, Context, unrollHint, skipExitCheck, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::OptimizeNone: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OptimizeNoneAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Overloadable: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OverloadableAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Override: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) OverrideAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Ownership: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * module = Record.getIdentifierInfo();
    unsigned argsSize = Record.readInt();
    SmallVector<unsigned, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readInt());
    New = new (Context) OwnershipAttr(Range, Context, module, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Packed: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PackedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ParamTypestate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    ParamTypestateAttr::ConsumedState paramState(static_cast<ParamTypestateAttr::ConsumedState>(Record.readInt()));
    New = new (Context) ParamTypestateAttr(Range, Context, paramState, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Pascal: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PascalAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PassObjectSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int type = Record.readInt();
    New = new (Context) PassObjectSizeAttr(Range, Context, type, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Pcs: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    PcsAttr::PCSType pCS(static_cast<PcsAttr::PCSType>(Record.readInt()));
    New = new (Context) PcsAttr(Range, Context, pCS, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PragmaClangBSSSection: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) PragmaClangBSSSectionAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PragmaClangDataSection: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) PragmaClangDataSectionAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PragmaClangRodataSection: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) PragmaClangRodataSectionAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PragmaClangTextSection: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) PragmaClangTextSectionAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PreserveAll: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PreserveAllAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PreserveMost: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PreserveMostAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PtGuardedBy: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * arg = Record.readExpr();
    New = new (Context) PtGuardedByAttr(Range, Context, arg, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::PtGuardedVar: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PtGuardedVarAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Pure: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) PureAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::RegCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) RegCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ReleaseCapability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) ReleaseCapabilityAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::RenderScriptKernel: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) RenderScriptKernelAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ReqdWorkGroupSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned xDim = Record.readInt();
    unsigned yDim = Record.readInt();
    unsigned zDim = Record.readInt();
    New = new (Context) ReqdWorkGroupSizeAttr(Range, Context, xDim, yDim, zDim, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::RequireConstantInit: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) RequireConstantInitAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::RequiresCapability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) RequiresCapabilityAttr(Range, Context, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Restrict: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) RestrictAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ReturnTypestate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    ReturnTypestateAttr::ConsumedState state(static_cast<ReturnTypestateAttr::ConsumedState>(Record.readInt()));
    New = new (Context) ReturnTypestateAttr(Range, Context, state, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ReturnsNonNull: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ReturnsNonNullAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ReturnsTwice: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ReturnsTwiceAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SAXIAdaptor: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    std::string clock= Record.readString();
    New = new (Context) SAXIAdaptorAttr(Range, Context, name, clock, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SAXILITEOffsetInterface: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    std::string bundleName= Record.readString();
    Expr * offset = Record.readExpr();
    bool isRegister = Record.readInt();
    std::string signalName= Record.readString();
    std::string clockName= Record.readString();
    std::string implName= Record.readString();
    New = new (Context) SAXILITEOffsetInterfaceAttr(Range, Context, port, bundleName, offset, isRegister, signalName, clockName, implName, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SDxKernel: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string rTLName= Record.readString();
    bool genericInterface = Record.readInt();
    New = new (Context) SDxKernelAttr(Range, Context, rTLName, genericInterface, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ScopedLockable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ScopedLockableAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Section: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) SectionAttr(Range, Context, name, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SelectAny: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SelectAnyAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Sentinel: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int sentinel = Record.readInt();
    int nullPos = Record.readInt();
    New = new (Context) SentinelAttr(Range, Context, sentinel, nullPos, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SetTypestate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    SetTypestateAttr::ConsumedState newState(static_cast<SetTypestateAttr::ConsumedState>(Record.readInt()));
    New = new (Context) SetTypestateAttr(Range, Context, newState, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SharedTrylockFunction: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * successValue = Record.readExpr();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) SharedTrylockFunctionAttr(Range, Context, successValue, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::StdCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) StdCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Suppress: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned diagnosticIdentifiersSize = Record.readInt();
    SmallVector<StringRef, 4> diagnosticIdentifiers;
    diagnosticIdentifiers.reserve(diagnosticIdentifiersSize);
    SmallVector<std::string, 4> diagnosticIdentifiersStorage;
    diagnosticIdentifiersStorage.reserve(diagnosticIdentifiersSize);
    for (unsigned i = 0; i != diagnosticIdentifiersSize; ++i)
      diagnosticIdentifiersStorage.push_back(Record.readString());
    for (unsigned i = 0; i != diagnosticIdentifiersSize; ++i)
      diagnosticIdentifiers.push_back(diagnosticIdentifiersStorage[i]);
    New = new (Context) SuppressAttr(Range, Context, diagnosticIdentifiers.data(), diagnosticIdentifiersSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SwiftCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SwiftCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SwiftContext: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SwiftContextAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SwiftErrorResult: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SwiftErrorResultAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SwiftIndirectResult: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SwiftIndirectResultAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::SysVABI: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) SysVABIAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TLSModel: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string model= Record.readString();
    New = new (Context) TLSModelAttr(Range, Context, model, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Target: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string featuresStr= Record.readString();
    New = new (Context) TargetAttr(Range, Context, featuresStr, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TestTypestate: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    TestTypestateAttr::ConsumedState testState(static_cast<TestTypestateAttr::ConsumedState>(Record.readInt()));
    New = new (Context) TestTypestateAttr(Range, Context, testState, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::ThisCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ThisCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Thread: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) ThreadAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TransparentUnion: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) TransparentUnionAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TryAcquireCapability: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * successValue = Record.readExpr();
    unsigned argsSize = Record.readInt();
    SmallVector<Expr *, 4> args;
    args.reserve(argsSize);
    for (unsigned i = 0; i != argsSize; ++i)
      args.push_back(Record.readExpr());
    New = new (Context) TryAcquireCapabilityAttr(Range, Context, successValue, args.data(), argsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TypeTagForDatatype: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    IdentifierInfo * argumentKind = Record.getIdentifierInfo();
    TypeSourceInfo * matchingCType = Record.getTypeSourceInfo();
    bool layoutCompatible = Record.readInt();
    bool mustBeNull = Record.readInt();
    New = new (Context) TypeTagForDatatypeAttr(Range, Context, argumentKind, matchingCType, layoutCompatible, mustBeNull, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::TypeVisibility: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    TypeVisibilityAttr::VisibilityType visibility(static_cast<TypeVisibilityAttr::VisibilityType>(Record.readInt()));
    New = new (Context) TypeVisibilityAttr(Range, Context, visibility, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Unavailable: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string message= Record.readString();
    UnavailableAttr::ImplicitReason implicitReason(static_cast<UnavailableAttr::ImplicitReason>(Record.readInt()));
    New = new (Context) UnavailableAttr(Range, Context, message, implicitReason, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Unpacked: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) UnpackedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Unused: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) UnusedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Used: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) UsedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Uuid: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string guid= Record.readString();
    New = new (Context) UuidAttr(Range, Context, guid, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::VecReturn: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) VecReturnAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::VecTypeHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    TypeSourceInfo * typeHint = Record.getTypeSourceInfo();
    New = new (Context) VecTypeHintAttr(Range, Context, typeHint, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::VectorCall: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) VectorCallAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Visibility: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    VisibilityAttr::VisibilityType visibility(static_cast<VisibilityAttr::VisibilityType>(Record.readInt()));
    New = new (Context) VisibilityAttr(Range, Context, visibility, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::WarnUnused: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) WarnUnusedAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::WarnUnusedResult: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) WarnUnusedResultAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::Weak: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) WeakAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::WeakImport: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) WeakImportAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::WeakRef: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string aliasee= Record.readString();
    New = new (Context) WeakRefAttr(Range, Context, aliasee, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::WorkGroupSizeHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned xDim = Record.readInt();
    unsigned yDim = Record.readInt();
    unsigned zDim = Record.readInt();
    New = new (Context) WorkGroupSizeHintAttr(Range, Context, xDim, yDim, zDim, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::X86ForceAlignArgPointer: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) X86ForceAlignArgPointerAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLArrayGeometry: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned dimsSize = Record.readInt();
    SmallVector<Expr *, 4> dims;
    dims.reserve(dimsSize);
    for (unsigned i = 0; i != dimsSize; ++i)
      dims.push_back(Record.readExpr());
    New = new (Context) XCLArrayGeometryAttr(Range, Context, dims.data(), dimsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLArrayView: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XCLArrayViewAttr::AccessModeType accessMode(static_cast<XCLArrayViewAttr::AccessModeType>(Record.readInt()));
    Expr * array = Record.readExpr();
    unsigned shapeSize = Record.readInt();
    SmallVector<Expr *, 4> shape;
    shape.reserve(shapeSize);
    for (unsigned i = 0; i != shapeSize; ++i)
      shape.push_back(Record.readExpr());
    New = new (Context) XCLArrayViewAttr(Range, Context, accessMode, array, shape.data(), shapeSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLArrayXForm: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XCLArrayXFormAttr::XCLArrayXFormType type(static_cast<XCLArrayXFormAttr::XCLArrayXFormType>(Record.readInt()));
    Expr * factor = Record.readExpr();
    Expr * dim = Record.readExpr();
    New = new (Context) XCLArrayXFormAttr(Range, Context, type, factor, dim, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLDataFlow: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XCLDataFlowAttr::PropagationType propagation(static_cast<XCLDataFlowAttr::PropagationType>(Record.readInt()));
    New = new (Context) XCLDataFlowAttr(Range, Context, propagation, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLDependence: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XCLDependenceAttr::XlxDepClass xClass(static_cast<XCLDependenceAttr::XlxDepClass>(Record.readInt()));
    XCLDependenceAttr::XlxDepType type(static_cast<XCLDependenceAttr::XlxDepType>(Record.readInt()));
    XCLDependenceAttr::XlxDepDirection direction(static_cast<XCLDependenceAttr::XlxDepDirection>(Record.readInt()));
    Expr * distance = Record.readExpr();
    bool compel = Record.readInt();
    New = new (Context) XCLDependenceAttr(Range, Context, variable, xClass, type, direction, distance, compel, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLFlattenLoop: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool enable = Record.readInt();
    New = new (Context) XCLFlattenLoopAttr(Range, Context, enable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLInline: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int recursive = Record.readInt();
    New = new (Context) XCLInlineAttr(Range, Context, recursive, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLLatency: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * min = Record.readExpr();
    Expr * max = Record.readExpr();
    New = new (Context) XCLLatencyAttr(Range, Context, min, max, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLLoopTripCount: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * min = Record.readExpr();
    Expr * max = Record.readExpr();
    Expr * avg = Record.readExpr();
    New = new (Context) XCLLoopTripCountAttr(Range, Context, min, max, avg, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLMaxWorkGroupSize: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned xDim = Record.readInt();
    unsigned yDim = Record.readInt();
    unsigned zDim = Record.readInt();
    New = new (Context) XCLMaxWorkGroupSizeAttr(Range, Context, xDim, yDim, zDim, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLOutline: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) XCLOutlineAttr(Range, Context, name, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLPipelineLoop: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * iI = Record.readExpr();
    New = new (Context) XCLPipelineLoopAttr(Range, Context, iI, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLPipelineWorkitems: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * iI = Record.readExpr();
    New = new (Context) XCLPipelineWorkitemsAttr(Range, Context, iI, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLRealProbe: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    int recursive = Record.readInt();
    New = new (Context) XCLRealProbeAttr(Range, Context, recursive, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLRegionName: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    std::string name= Record.readString();
    New = new (Context) XCLRegionNameAttr(Range, Context, name, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLReqdPipeDepth: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * depth = Record.readExpr();
    int type = Record.readInt();
    New = new (Context) XCLReqdPipeDepthAttr(Range, Context, depth, type, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLSingleWorkitem: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) XCLSingleWorkitemAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLUnrollWorkitems: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned unrollHint = Record.readInt();
    New = new (Context) XCLUnrollWorkitemsAttr(Range, Context, unrollHint, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLVisibility: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XCLVisibilityAttr::XCLVisibilityType visibility(static_cast<XCLVisibilityAttr::XCLVisibilityType>(Record.readInt()));
    New = new (Context) XCLVisibilityAttr(Range, Context, visibility, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XCLZeroGlobalWorkOffset: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) XCLZeroGlobalWorkOffsetAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XRayInstrument: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) XRayInstrumentAttr(Range, Context, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XRayLogArgs: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned argumentCount = Record.readInt();
    New = new (Context) XRayLogArgsAttr(Range, Context, argumentCount, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxAggregate: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XlxAggregateAttr::Compact compact(static_cast<XlxAggregateAttr::Compact>(Record.readInt()));
    New = new (Context) XlxAggregateAttr(Range, Context, variable, compact, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxArrayGeometry: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned dimsSize = Record.readInt();
    SmallVector<Expr *, 4> dims;
    dims.reserve(dimsSize);
    for (unsigned i = 0; i != dimsSize; ++i)
      dims.push_back(Record.readExpr());
    New = new (Context) XlxArrayGeometryAttr(Range, Context, dims.data(), dimsSize, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxArrayPartitionXForm: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XlxArrayPartitionXFormAttr::XlxArrayPartitionXFormType type(static_cast<XlxArrayPartitionXFormAttr::XlxArrayPartitionXFormType>(Record.readInt()));
    Expr * factor = Record.readExpr();
    Expr * dim = Record.readExpr();
    bool dynamic = Record.readInt();
    New = new (Context) XlxArrayPartitionXFormAttr(Range, Context, variable, type, factor, dim, dynamic, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxArrayReshapeXForm: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XlxArrayReshapeXFormAttr::XlxArrayReshapeXFormType type(static_cast<XlxArrayReshapeXFormAttr::XlxArrayReshapeXFormType>(Record.readInt()));
    Expr * factor = Record.readExpr();
    Expr * dim = Record.readExpr();
    New = new (Context) XlxArrayReshapeXFormAttr(Range, Context, variable, type, factor, dim, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxArrayStencil: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    bool enabled = Record.readInt();
    New = new (Context) XlxArrayStencilAttr(Range, Context, variable, enabled, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxArrayView: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XlxArrayViewAttr::AccessModeType accessMode(static_cast<XlxArrayViewAttr::AccessModeType>(Record.readInt()));
    Expr * array = Record.readExpr();
    unsigned shapeSize = Record.readInt();
    SmallVector<Expr *, 4> shape;
    shape.reserve(shapeSize);
    for (unsigned i = 0; i != shapeSize; ++i)
      shape.push_back(Record.readExpr());
    New = new (Context) XlxArrayViewAttr(Range, Context, accessMode, array, shape.data(), shapeSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxBindOp: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    Expr * op = Record.readExpr();
    Expr * impl = Record.readExpr();
    Expr * latency = Record.readExpr();
    New = new (Context) XlxBindOpAttr(Range, Context, variable, op, impl, latency, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxBindOpExpr: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    Expr * op = Record.readExpr();
    Expr * impl = Record.readExpr();
    Expr * latency = Record.readExpr();
    New = new (Context) XlxBindOpExprAttr(Range, Context, variable, op, impl, latency, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxBindStorage: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    Expr * type = Record.readExpr();
    Expr * impl = Record.readExpr();
    Expr * latency = Record.readExpr();
    New = new (Context) XlxBindStorageAttr(Range, Context, variable, type, impl, latency, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxCache: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * port = Record.readExpr();
    Expr * lines = Record.readExpr();
    Expr * depth = Record.readExpr();
    Expr * ways = Record.readExpr();
    Expr * users = Record.readExpr();
    XlxCacheAttr::BurstMode burst(static_cast<XlxCacheAttr::BurstMode>(Record.readInt()));
    XlxCacheAttr::WriteMode write(static_cast<XlxCacheAttr::WriteMode>(Record.readInt()));
    New = new (Context) XlxCacheAttr(Range, Context, port, lines, depth, ways, users, burst, write, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxCrossDependence: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * crossVar0 = Record.readExpr();
    Expr * crossVar1 = Record.readExpr();
    XlxCrossDependenceAttr::XlxDepClass xClass(static_cast<XlxCrossDependenceAttr::XlxDepClass>(Record.readInt()));
    XlxCrossDependenceAttr::XlxDepType type(static_cast<XlxCrossDependenceAttr::XlxDepType>(Record.readInt()));
    XlxCrossDependenceAttr::XlxDepDirection direction(static_cast<XlxCrossDependenceAttr::XlxDepDirection>(Record.readInt()));
    Expr * distance = Record.readExpr();
    bool compel = Record.readInt();
    New = new (Context) XlxCrossDependenceAttr(Range, Context, crossVar0, crossVar1, xClass, type, direction, distance, compel, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxDataPack: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XlxDataPackAttr::BytePadLevel bytePadLevel(static_cast<XlxDataPackAttr::BytePadLevel>(Record.readInt()));
    New = new (Context) XlxDataPackAttr(Range, Context, variable, bytePadLevel, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxDependence: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    XlxDependenceAttr::XlxDepClass xClass(static_cast<XlxDependenceAttr::XlxDepClass>(Record.readInt()));
    XlxDependenceAttr::XlxDepType type(static_cast<XlxDependenceAttr::XlxDepType>(Record.readInt()));
    XlxDependenceAttr::XlxDepDirection direction(static_cast<XlxDependenceAttr::XlxDepDirection>(Record.readInt()));
    Expr * distance = Record.readExpr();
    bool compel = Record.readInt();
    New = new (Context) XlxDependenceAttr(Range, Context, variable, xClass, type, direction, distance, compel, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxDisaggr: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    New = new (Context) XlxDisaggrAttr(Range, Context, variable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxExprBalance: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool enabled = Record.readInt();
    New = new (Context) XlxExprBalanceAttr(Range, Context, enabled, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxFlattenLoop: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool enable = Record.readInt();
    New = new (Context) XlxFlattenLoopAttr(Range, Context, enable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxFuncInstantiate: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    New = new (Context) XlxFuncInstantiateAttr(Range, Context, variable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxFunctionAllocation: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * function = Record.readExpr();
    Expr * limit = Record.readExpr();
    New = new (Context) XlxFunctionAllocationAttr(Range, Context, function, limit, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxInfiniteTask: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * taskID = Record.readExpr();
    New = new (Context) XlxInfiniteTaskAttr(Range, Context, taskID, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxLoopTripCount: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * min = Record.readExpr();
    Expr * max = Record.readExpr();
    Expr * avg = Record.readExpr();
    New = new (Context) XlxLoopTripCountAttr(Range, Context, min, max, avg, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxMAXIAlias: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned portsSize = Record.readInt();
    SmallVector<Expr *, 4> ports;
    ports.reserve(portsSize);
    for (unsigned i = 0; i != portsSize; ++i)
      ports.push_back(Record.readExpr());
    unsigned offsetsSize = Record.readInt();
    SmallVector<Expr *, 4> offsets;
    offsets.reserve(offsetsSize);
    for (unsigned i = 0; i != offsetsSize; ++i)
      offsets.push_back(Record.readExpr());
    New = new (Context) XlxMAXIAliasAttr(Range, Context, ports.data(), portsSize, offsets.data(), offsetsSize, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxMergeLoop: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool force = Record.readInt();
    New = new (Context) XlxMergeLoopAttr(Range, Context, force, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxOccurrence: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * cycle = Record.readExpr();
    New = new (Context) XlxOccurrenceAttr(Range, Context, cycle, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxPerformance: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * targetTI = Record.readExpr();
    Expr * targetTL = Record.readExpr();
    Expr * assumeTI = Record.readExpr();
    Expr * assumeTL = Record.readExpr();
    XlxPerformanceAttr::PerformanceScopeType performanceScope(static_cast<XlxPerformanceAttr::PerformanceScopeType>(Record.readInt()));
    New = new (Context) XlxPerformanceAttr(Range, Context, targetTI, targetTL, assumeTI, assumeTL, performanceScope, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxPipeline: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * iI = Record.readExpr();
    int style = Record.readInt();
    bool rewind = Record.readInt();
    New = new (Context) XlxPipelineAttr(Range, Context, iI, style, rewind, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxProtocol: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    XlxProtocolAttr::ProtocolModeType protocolMode(static_cast<XlxProtocolAttr::ProtocolModeType>(Record.readInt()));
    New = new (Context) XlxProtocolAttr(Range, Context, protocolMode, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxReqdPipeDepth: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    Expr * depth = Record.readExpr();
    int type = Record.readInt();
    New = new (Context) XlxReqdPipeDepthAttr(Range, Context, variable, depth, type, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxResetIntrinsic: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    bool enabled = Record.readInt();
    New = new (Context) XlxResetIntrinsicAttr(Range, Context, variable, enabled, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxRewinding: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    New = new (Context) XlxRewindingAttr(Range, Context, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxShared: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    New = new (Context) XlxSharedAttr(Range, Context, variable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxStable: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    New = new (Context) XlxStableAttr(Range, Context, variable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxStableContent: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * variable = Record.readExpr();
    New = new (Context) XlxStableContentAttr(Range, Context, variable, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxTask: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * taskID = Record.readExpr();
    New = new (Context) XlxTaskAttr(Range, Context, taskID, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxUnrollHint: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    Expr * factor = Record.readExpr();
    bool skipExitCheck = Record.readInt();
    bool isDefaultFactor = Record.readInt();
    New = new (Context) XlxUnrollHintAttr(Range, Context, factor, skipExitCheck, isDefaultFactor, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxUnrollRegionHint: {
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    unsigned unrollHint = Record.readInt();
    bool skipExitCheck = Record.readInt();
    New = new (Context) XlxUnrollRegionHintAttr(Range, Context, unrollHint, skipExitCheck, Spelling);
    New->setImplicit(isImplicit);
    break;
  }
  case attr::XlxVarReset: {
    bool isInherited = Record.readInt();
    bool isImplicit = Record.readInt();
    unsigned Spelling = Record.readInt();
    bool enabled = Record.readInt();
    New = new (Context) XlxVarResetAttr(Range, Context, enabled, Spelling);
    cast<InheritableAttr>(New)->setInherited(isInherited);
    New->setImplicit(isImplicit);
    break;
  }
  }
